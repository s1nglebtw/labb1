# lab_1
## Задача 00
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/d24d0548-cd5c-4984-be56-0a9d4698ec0d)
### **Задача 0. Алгоритм**
1. Высчитываем расстояние с помощью функции def rast(x,y)
2. Создаем словарь distances
3. for key in sites.keys():
    distances[key] = {}
   Эта строка создает пустой словарь distances с ключом key для каждого ключа в словаре sites. То есть, для каждого ключа в словаре sites создается элемент в словаре distances.
4. for y in sites.keys():
   if y!=key:
   Эта строка создает вложенный цикл, который перебирает все ключи в словаре sites, исключая текущий ключ key. Это нужно для того, чтобы не вычислять расстояние между ключом и самим собой.
5. distances[key][y] = rast(sites[key], sites[y]) Эта строка вычисляет расстояние между значениями x и y, связанными с ключами key и у в словаре sites с помощью функции rast, и сохраняет результат в словаре distances в виде distances[key][y], представляя расстояние между ключом key и ключом y в словаре sites.
6. Выводим результат

## Задача 01
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/65728253-d6c0-400f-920a-8dd2232df935)
### **Задача 1. Алгоритм**
1. Находим площадь круга с помощью функции def krug(r)
2. Выводим результат
3. Определяем находятся ли точки point_1 и point_2 внутри круга
4. Выводим результат

## Задача 02
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/27601928-9b33-4776-8c30-1c871f5e9b1e)
### **Задача 02. Алгоритм**
1. Расставляем знаки, как показано в условии
2. Выводим результат

## Задача 03
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/f6951ea7-2256-468c-83bd-9bbb47e5d4d6)
### **Задача 03. Алгоритм**
1. С помощью срезов выводим сразу результат

## Задача 04
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/f68f33d8-3a20-480d-8116-a8ec5a138228)
### **Задача 04. Алгоритм**
1. Создаем список
2. Создаем список с приблизительным ростом
3. В переменной father_height находим рост с помощью перебора списка и функции next, которая возвращает элемент, который соответствует условию
4. В переменной total_height вычисляем общий рост семьи с помощью функции sum
5. Выводим результат

## Задача 05
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/63cea275-262b-4576-9e00-32f0fce0b648)
### **Задача 05. Алгоритм**
1. С помощью функции insert добавляем медведя в список с помощью индекса
2. Добавляем птиц в список с помощью суммирования
3. С помощью remove удаляем из списка слона
4. Выводим на консоль в какой клетке сидит лев и жаворонок, но добавляем +1, чтобы было понятно другим людям

## Задача 06
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/3c642c95-993b-4e98-bda2-a9faba8f6046)
### **Задача 06. Алгоритм**
1. В переменных mus1, mus2, mus3 с помощью функции next возвращает элемент, который соответствует условию
2. В переменной s суммируем значения и выводим их с помощью округления (round)
3. В переменной totaltime складываем время звучания песен
4. В переменной othersongstime складываем 3 другие песни
5. Выводим

## Задача 07
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/f091bc16-c79c-43c7-90f5-313657aa398d)
### **Задача 07. Алгоритм**
1. С помощью срезов выводим значение

## Задача 08
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/486978e4-59ce-4e6e-811c-701c42d5e8ac)

### **Задача 08. Алгоритм**
1. Создаем множество цветоы с помощью функции set
2. С помощью union объединяем множества и выводим их
3. С помощью intersection находим пересечения в множествах и выводим их
4. С помощью difference возвращаем множество, полученное из различий между множествами

## Задача 09
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/19b388f4-3f4e-4a13-abc5-625d988eaf2b)

### **Задача 09. Алгоритм**
1. В переменной sweets создаем словарь цен на продукты
2. Выводим их

## Задача 10
**Результат**
![image](https://github.com/eternsss/lab_1/assets/155539142/82a0a4a7-d06a-43a5-ab56-33dbb63b75a6)

### **Задача 10. Алгоритм**
1. В lamp_cost и др находим общую сумму товаров
2. В lamp_quantity находим общее количество товаров
3. Выводим результат

# lab_2
## Задача 1
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab2.1.PNG)
### **Задача 1. Алгоритм**
1. Алфавит делится на две группы: первые 2 символа (X, Z) и остальные 5 символов (A, B, C, D, E)
2. Для первых двух позиций кода генерируются все возможные упорядоченные пары из первой группы (с повторениями)
   - Это дает 2 × 2 = 4 комбинации
3. Для последних двух позиций кода генерируются все возможные упорядоченные пары из второй группы (с повторениями)
   - Это дает 5 × 5 = 25 комбинаций
4. Поскольку группы независимы, общее количество кодовых слов вычисляется умножением:
   - 4 (комбинации первых двух символов) × 25 (комбинации последних двух символов) = 100
5. Результат выводится на экран с пояснительным текстом
## Задача 2
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab2.2.PNG)
### **Задача 2. Алгоритм**
1. Вычисляется большое число по формуле: 49^10 + 7^30 - 49
2. Это число переводится из десятичной системы в семеричную:
   - Пока число больше 0:
     * Берется остаток от деления на 7 — это очередная цифра справа
     * Число делится нацело на 7 (отбрасывается младший разряд)
     * Цифра добавляется слева к строковому представлению числа в 7-ричной системе
3. В полученном 7-ричном числе подсчитываются все цифры "6":
   - Число преобразуется в строку
   - Каждый символ проверяется на равенство "6"
   - Подсчитывается количество таких символов
4. Результат (количество цифр "6") выводится на экран
## Задача 3
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab2.3.PNG)
### **Задача 3. Алгоритм**
1. Для каждого числа n в диапазоне от 312614 до 312651:
   - Вызывается функция finder(n) для нахождения всех делителей

2. Функция finder(n) находит все делители числа:
   - Создается начальный список делителей [1, n]
   - Проверяются числа от 2 до квадратного корня из n:
     * Если i делит n без остатка (n % i == 0):
       - i добавляется в список делителей
       - Если i ≠ n//i (избегаем дублирования для квадратов), то n//i тоже добавляется
   - Список сортируется по возрастанию и возвращается

3. Для каждого числа проверяется: если количество делителей равно 6
   - Все делители выводятся в строку через пробел (*numbers)

4. Таким образом программа находит и выводит все числа из диапазона, 
   которые имеют ровно 6 делителей, вместе с этими делителями

# lab_3
## Задача 1
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab3.1.PNG)
### **Задача 1. Алгоритм**
Первая реализация (рекурсивная):
1. Функция is_palindrome(s) проверяет, является ли строка/список палиндромом:
   - Если длина ≤ 1 → сразу True (базовый случай)
   - Если первый и последний элементы не равны → сразу False
   - Иначе: рекурсивный вызов для подстроки/подсписка без первого и последнего элементов

2. Тестирование:
   - [12321] → True (длина 1, базовый случай)
   - "spam" → False ('s' ≠ 'm')

Вторая реализация (через срез):
1. Функция is_palindrome(d) (переопределяет первую):
   - Сравнивает объект с его перевернутой версией через срез [::-1]
   - Если равны → True, иначе → False

2. Тестирование тех же данных:
   - [12321] → True (список равен своему перевернутому виду)
   - "spam" → False ("spam" ≠ "maps")
## Задача 2
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab3.2.PNG)
### **Задача 2. Алгоритм**
2. Для i=6 вычисляется:
   - x(6) = x(5) + x(3)
   - x(5) = x(4) + x(2)
   - x(4) = x(3) + x(1) = 1+1=2
   - Подставляем: x(5)=2+1=3, x(6)=3+1=4

Вторая реализация (итеративная):
1. Та же функция (переопределяет первую) использует три переменные:
   - x1, x2, x3 хранят три предыдущих значения (начально все =1)
   - Цикл от 4 до i последовательно вычисляет новые значения

2. Для i=6:
   - j=4: result=1+1=2, x1=1, x2=1, x3=2
   - j=5: result=1+2=3, x1=1, x2=2, x3=3  
   - j=6: result=2+3=5, возвращается 5
# lab_4
## Задача 1
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab4.1.PNG)
### **Задача 1. Алгоритм**
1. Функция zamik() создает и возвращает внутреннюю функцию-замыкание:
   - Открывает файл "out.txt" для записи
   - Определяет внутреннюю функцию closure(), которая имеет доступ к файлу f

2. Внутренняя функция closure():
   - Бесконечно запрашивает ввод у пользователя
   - Если введено "exit" — завершает цикл
   - Иначе — записывает введенное значение в файл с переводом строки

3. После создания функции-замыкания:
   - zm1 = zamik() создает экземпляр с собственным файловым дескриптором
   - Вызов zm1() запускает интерактивный ввод данных
   - Все введенные значения сохраняются в файл out.txt

4. После завершения ввода (по команде "exit"):
   - Выводится сообщение о том, что значения записаны в файл
   - Файл автоматически закрывается сборщиком мусора (явное закрытие отсутствует)
## Задача 2
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab4.2.PNG)
### **Задача 2. Алгоритм**
1. Создается декоратор `decor`:
   - Принимает асинхронную функцию как аргумент
   - Возвращает асинхронную функцию-обертку `wrapper`
   - Обертка вызывает исходную функцию с теми же аргументами через `await`

2. Асинхронная функция `async_func` декорируется:
   - Ждет 1 секунду (`await asyncio.sleep(1)`)
   - Выводит "All good!"

3. Основная асинхронная функция `main`:
   - Четыре раза подряд вызывает `await async_func()`
   - После каждого вывода "All good!" от функции выводит свой текст:
     * "All good!??"
     * "All good!__"  
     * "All good!+++"

4. Запуск:
   - `asyncio.run(main())` запускает асинхронный цикл
   - Все вызовы выполняются последовательно (не параллельно), так как каждый `await` ждет завершения предыдущего
# lab_5
## Задача 1
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab5.PNG)
### **Задача 1. Алгоритм**
1. Функция pixel_generator(image_path):
   - Открывает изображение и конвертирует в RGB при необходимости
   - Создает генератор, который последовательно выдает:
     * Координаты (x, y) каждого пикселя
     * Его цвет в формате (R, G, B)

2. Функция invert_color(pixel_data):
   - Принимает данные пикселя (x, y, (r, g, b))
   - Инвертирует каждый цветовой канал: 255 - значение
   - Возвращает кортеж (x, y, инвертированный_цвет)

3. Функция apply_pixels_to_image(...):
   - Создает копию исходного изображения
   - Проходит по списку обработанных пикселей
   - Устанавливает каждый пиксель в новом изображении в инвертированный цвет
   - Сохраняет результат в файл

4. Основная функция invert_image_colors(input_image, output_image):
   - Получает генератор пикселей из исходного изображения
   - Применяет map() с функцией invert_color к каждому пикселю
   - Передает поток инвертированных пикселей для создания нового изображения

5. Результат:
   - Создается новое изображение с инвертированными цветами
   - Сохраняется в указанный выходной файл
# lab_6
## Задача 1
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab6.PNG)
### **Задача 1. Алгоритм**
ОСНОВНОЙ ФАЙЛ (ГРАФИЧЕСКИЙ ИНТЕРФЕЙС):

1. Создание графического интерфейса с библиотекой guizero:
   - Поле для ввода площади помещения
   - Выпадающий список для выбора материала (обои, плитка, ламинат)
   - Кнопки: "Рассчитать", "Сохранить в DOCX", "Сохранить в XLSX"
   - Область для вывода результатов

2. Функция calculate() - основной расчёт:
   - Получает площадь и выбранный материал из полей ввода
   - В зависимости от материала вызывает соответствующую функцию из модулей packet
   - Результат (словарь с данными) сохраняется в глобальную переменную last_result
   - Форматирует и выводит результат в интерфейсе

3. Функции сохранения результатов:
   - save_docx(): создаёт Word-документ с результатами
   - save_xlsx(): создаёт Excel-файл с результатами
   - Обе проверяют, что расчёт был выполнен (last_result не пустой)
   - Сохраняют файлы в папку "reports"

МОДУЛИ РАСЧЁТА (ПАПКА PACKET):

Модуль laminate.py (расчёт ламината):
   - Принимает: площадь, площадь одной упаковки, цену упаковки
   - Рассчитывает: количество упаковок (округляя вверх)
   - Возвращает: словарь с материалом, площадью, количеством упаковок и стоимостью

Модуль oboi.py (расчёт обоев):
   - Принимает: площадь, ширину рулона, длину рулона, цену рулона
   - Рассчитывает: площадь одного рулона, количество рулонов (округляя вверх)
   - Возвращает: аналогичный словарь с результатами

Модуль plitka.py (расчёт плитки):
   - Принимает: площадь, размер плитки (в см), количество плиток в коробке, цену коробки
   - Рассчитывает: площадь одной плитки (переводит в м²), общее количество плиток, 
     количество коробок (округляя вверх)
   - Возвращает: словарь с результатами

ОБЩАЯ ЛОГИКА:
   1. Пользователь вводит данные в графическом интерфейсе
   2. При нажатии "Рассчитать" выбирается соответствующий алгоритм расчёта
   3. Результаты показываются на экране и сохраняются для возможного экспорта
   4. Пользователь может экспортировать результаты в Word или Excel
### Список источников:
    1. guizero документация PyPi: pypi.org/project/guizero
    2. python docx документация PyPi: pypi.org/project/python-docx
    3. python openyxl документация PyPi: pypi.org/project/openpyxl
# lab_7
## Задача 1
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab7.PNG)
### **Задача 1. Алгоритм**
ОСНОВНОЙ ФАЙЛ (ГРАФИЧЕСКИЙ ИНТЕРФЕЙС):

1. Создание улучшенного графического интерфейса:
   - Добавлены поля для ввода: площади единицы материала и цены за единицу
   - Выпадающий список материалов использует словарь для связи с классами

2. Новая логика работы функции calculate():
   - Получает класс материала из словаря materials по выбранному названию
   - Создаёт объект этого класса с введёнными параметрами
   - Вызывает метод calculate() у созданного объекта
   - Сохраняет результат в last_result и выводит в интерфейсе

3. Функции сохранения (аналогичны предыдущей версии):
   - save_docx() - создаёт Word-документ
   - save_xlsx() - создаёт Excel-файл
   - Проверяют наличие результатов перед сохранением

СИСТЕМА КЛАССОВ (ПАПКА MATERIALS):

1. Базовый абстрактный класс Material (base.py):
   - Определяет общие свойства: площадь помещения, цена, площадь единицы
   - Использует property-декораторы для валидации входных данных
   - Содержит защищённый метод _base_calculate() для общего расчёта
   - Определяет абстрактный метод calculate() (должен быть реализован в наследниках)
   - Реализует dunder-методы: __str__ и __len__

2. Классы-наследники (ламинат, обои, плитка):
   - Каждый наследует от Material
   - Реализуют метод calculate() через вызов _base_calculate()
   - Добавляют свои dunder-методы: __repr__ и __eq__
   - Ламинат сравнивается по цене, обои - по площади, плитка - по площади единицы

ПРИНЦИПИАЛЬНЫЕ ОТЛИЧИЯ ОТ ПРЕДЫДУЩЕЙ ВЕРСИИ:

1. Объектно-ориентированный подход вместо функций:
   - Каждый материал - это класс, наследующий общую логику
   - Инкапсуляция данных через свойства (property)
   - Полиморфизм - разные классы используют общий интерфейс

2. Улучшенная валидация данных:
   - Проверка на положительные значения при установке свойств
   - Исключения при некорректных данных

3. Гибкая архитектура:
   - Легко добавлять новые типы материалов
   - Единая точка входа для расчётов
   - Переиспользование кода через наследование

ОБЩАЯ ЛОГИКА РАБОТЫ:
   1. Пользователь выбирает материал и вводит три параметра
   2. Создаётся объект соответствующего класса
   3. Выполняется расчёт по единой формуле (количество = площадь/площадь_единицы)
   4. Результаты можно сохранить в разных форматах
### Список источников:
    1. guizero документация PyPi: pypi.org/project/guizero
    2. python docx документация PyPi: pypi.org/project/python-docx
    3. python openyxl документация PyPi: pypi.org/project/openpyxl
    4. python ABC abstract base classes: docs.python.org/3/library/abc.html
# lab_8
## Задача 1
**Результат**
![image](https://github.com/s1nglebtw/labb1/blob/main/screens/lab8.PNG)
### **Задача 1. Алгоритм**
ОСНОВНЫЕ КЛАССЫ:

1. Класс Task (Задача):
   - Хранит название и описание задачи
   - Проверяет, что название не пустое
   - Методы для преобразования в словарь и обратно

2. Класс Column (Колонка):
   - Представляет столбец канбан-доски (например, "В процессе")
   - Хранит список задач
   - Методы для добавления, удаления и поиска задач
   - Проверяет уникальность названий задач в пределах колонки

3. Класс KanbanApp (Основное приложение):
   - Управляет всем интерфейсом и логикой

ГРАФИЧЕСКИЙ ИНТЕРФЕЙС:

1. Верхняя панель:
   - Поля для ввода названия и описания новой задачи
   - Кнопки "Добавить" и "Сохранить"
   - Поле поиска с кнопками "Фильтр" и "Сброс"

2. Три колонки (расположены горизонтально):
   - "К выполнению", "В процессе", "Готово"
   - Каждая колонка содержит:
     * Заголовок
     * Список задач (ListBox)
     * Кнопки управления: Изменить, Удалить, ← (влево), → (вправо)

ОСНОВНЫЕ ФУНКЦИОНАЛЬНОСТИ:

1. Добавление задачи:
   - Создаётся объект Task и добавляется в первую колонку
   - Проверка на уникальность названия в колонке

2. Просмотр задачи:
   - Двойной клик по задаче открывает окно с полной информацией

3. Редактирование задачи:
   - Открывает окно с полями для изменения названия и описания
   - Проверка на уникальность нового названия

4. Удаление задачи:
   - Запрос подтверждения перед удалением

5. Перемещение задач между колонками:
   - Кнопки ← и → перемещают задачу в соседнюю колонку
   - Проверка, что перемещение возможно (не крайняя колонка)

6. Поиск и фильтрация:
   - Поиск задач по названию (регистронезависимый)
   - Кнопка "Сброс" возвращает полный список

7. Сохранение и загрузка:
   - Все данные сохраняются в JSON-файл
   - При запуске приложения данные автоматически загружаются

ОСОБЕННОСТИ РЕАЛИЗАЦИИ:

1. Фабрики функций (factory):
   - Для каждой кнопки создаётся функция с замыканием на индекс колонки
   - Это позволяет обрабатывать события с привязкой к конкретной колонке

2. Обработка исключений:
   - Специальные классы исключений для ошибок приложения
   - Валидация данных при создании и редактировании задач

3. Паттерн MVC:
   - Модель: Task, Column
   - Представление: guizero виджеты
   - Контроллер: KanbanApp

РАБОЧИЙ ПРОЦЕСС:
   1. Пользователь вводит новую задачу и добавляет её
   2. Задача появляется в колонке "К выполнению"
   3. По мере выполнения задачи перемещаются между колонками
   4. Все изменения автоматически отображаются в интерфейсе
   5. Данные сохраняются в файл для последующего использования
